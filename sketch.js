const trunc = (n, p) => Math.trunc(n * 10 ** p) / 10 ** p;

const screen_size = 800;
const pendulum_length = 180;
const rate1 = 1;
const rate2 = Math.PI;
const max_calc_change = 0.01;

let speed = 0.01;
let rot = 0;
let last_end2_x = 2 * pendulum_length;
let last_end2_y = 0;

let line_canvas;
function setup() {
  createCanvas(screen_size, screen_size);
  line_canvas = createGraphics(screen_size, screen_size);
}

function calc_render(change, render_pendulum) {
  if (render_pendulum)
    push();
  {
    // Set pendulum rendering attributes including rendering from the center of the canvas
    if (render_pendulum) {
      translate(screen_size / 2, screen_size / 2);
      stroke(255);
      strokeWeight(4);
    }
    
    // Base Pendulum (relative rotation speed of 1 since it's the base pendulum)
    const end1_x = cos(rot) * pendulum_length;
    const end1_y = sin(rot) * pendulum_length;
    if (render_pendulum)
      line(0, 0, end1_x, end1_y);
    
    // End Pendulum (relative rotation speed of pi)
    const end2_x = end1_x + cos(rot * PI) * pendulum_length;
    const end2_y = end1_y + sin(rot * PI) * pendulum_length;
    if (render_pendulum)
      line(end1_x, end1_y, end2_x, end2_y);
    
    // Draw the line generated by the movement
    line_canvas.push();
    {
      line_canvas.translate(screen_size / 2, screen_size / 2);
      line_canvas.stroke(255);
      line_canvas.strokeWeight(1);
      line_canvas.line(last_end2_x, last_end2_y, end2_x, end2_y);
    }
    line_canvas.pop();
    
    // Update the last coordinate of the end of the pendulum
    last_end2_x = end2_x;
    last_end2_y = end2_y;
  }
  if (render_pendulum)
    pop();
  
  rot -= change;
}

function render() {
  const direction = Math.sign(speed);
  let i;
  for (i = Math.abs(speed); i > max_calc_change; i -= max_calc_change)
    calc_render(direction * max_calc_change, false);
  calc_render(direction * i, true);
}

function draw() {
  background(0);

  // Calculate the rotation for each max_calc_change to keep the lines looking round
  const graph_offset_x = 0
  const graph_offset_y = -30;
  push();
  line_canvas.push();
  {
    translate(graph_offset_x, graph_offset_y);
    line_canvas.translate(graph_offset_x, graph_offset_y);
    
    render();
  }
  pop();
  line_canvas.pop();
  
  // Render the canvas containing the lines
  image(line_canvas, 0, 0);
  
  //String(speed)
  push();
  {
    fill(255);
    textFont('Courier New');
    textSize(24);
    text(`Speed: ${ trunc(speed, 3) }`, 10, 30);
    
    textAlign(CENTER);
    text(`Equation: r(θ) = e^θi + e^πθi`, screen_size / 2, screen_size - 30);
  }
  pop();
  
  describe("A visualization of the equation r(θ) = e^θi + e^πθi rendered using pendulums, which due to pi's irrational nature will never repeat the same path.");
}

function mouseWheel(event) {
  speed -= event.delta * 0.0001;
}